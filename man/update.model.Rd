% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/update.model.R
\name{update.model}
\alias{update.model}
\alias{update.multimodel}
\alias{absent}
\alias{null}
\alias{unchanged}
\title{Update an object of class \dQuote{model} or \dQuote{multimodel}}
\usage{
\method{update}{model}(
  object,
  ...,
  label = label.model(object),
  add_fit = FALSE,
  ignore_changes_in_arg = NULL
)

\method{update}{multimodel}(object, ...)

absent()

null()

unchanged()
}
\arguments{
\item{object}{A \dQuote{model} or \dQuote{multimodel}.}

\item{\dots}{Arguments to be updated.}

\item{label}{Character string: A label to be attributed to the model.}

\item{add_fit}{Logical: Save the fitted object as a component of the result?}

\item{ignore_changes_in_arg}{Parameter for internal use.}
}
\value{
\code{udpate.model()} returns the modified \link{model}.
If \dQuote{...} is empty, \code{x} is not changed. Otherwise, the output will not contain the model fit.
}
\description{
The method \code{update.model()} allows updating selected arguments in the original call to the model fitting function,
in particular \code{formula}, \code{data}.
Changing the model fitting function is not possible, however.
\code{update.multimodel()} will apply \code{update.model()} to each of its models.

\code{absent()}, \code{unchanged()} and \code{null()} are auxiliary functions designed for usage in \code{update.model()} and \code{multimodel()}.
\code{absent()} states the removal/absence of an argument in the model fitting call,
\code{unchanged()} leaves an argument unchanged, and \code{null()} attributes an explicit \code{NULL} to a formal parameter.
Find more about the usage of these functions in the the \dQuote{Details} section and the examples.
}
\details{
\code{update(model, parameter=NULL)} is ambiguous -- it's clearer to use \code{null()} or \code{absent()}.

Using a dot in a formula can be ambiguous, too. \code{update(model, formula=new_formula)} \emph{updates} the model's original formula
with \code{new_formula} (using \code{\link[stats]{update.formula}}).
In order to \emph{replace} the existing formula by a different one containing a dot, use \code{update(model, formula=I(new_formula))}.
See the examples.

\code{absent()}, \code{unchanged()} and \code{null()} can also be used in \code{multimodel()}, which uses \code{update.model()} internally.
As an example, \code{multimodel(lm(y~x), weights = list(w, absent()))} will return a multimodel containing the two model definitions
based on calls \code{lm(y~x, weights = w)} and \code{lm(y~x)}.
Always enclose \code{absent()}, \code{unchanged()} and \code{null()} in a \code{list()} if  several alternative model parameterizations are proposed
in \code{multimodel()}! The example won't work properly with \code{c(w, absent())} instead of \code{list(w, absent())}!
}
\examples{
if (require(lme4)){
  # Simluate data
  d <- simuldat()
  (mixmod <- lmer(Y ~ (X1|g) + X2 + X3, d, REML = TRUE))
  
  # update.model
  m_REML <- model(mixmod, label = "REML")
  # update parater "REML"
  m_ML <- update(m_REML, REML = FALSE, label = "ML")
  
  # absent(), unchanged(), null()
  update(m_REML, REML = absent())$call
  update(m_REML, REML = unchanged())$call
  update(m_REML, REML = null())$call # Note: not meaningful - fit() will fail
  
  # update.multimodel
  mm <- multimodel(m_REML, REML = c(TRUE, FALSE))
  w <- runif(nrow(d))
  update(mm, weights = w)
  
  # Dots in formula: 
  update(m_REML, formula = . ~ . - X2)
  
  # Updating vs replacing a formula:
  update(m_REML, formula = exp(Y) ~ .)    # updates the formula
  update(m_REML, formula = I(exp(Y) ~ .)) # replaces the formula
  
  # Usage of unchanged() in multimodel()
  multimodel(m_REML, REML = list(unchanged(), FALSE))
}

}
\seealso{
\code{\link{model}}, \code{\link{multimodel}}; \code{\link[stats]{update.formula}}
}
