% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.R, R/fm_glmnet.R, R/fm_xgb.R
\name{fit}
\alias{fit}
\alias{fit.model}
\alias{fit.multimodel}
\alias{fit.cv}
\alias{add_fit}
\alias{has_fit}
\alias{fit.model_fm_glmnet}
\alias{fit.model_fm_xgb}
\title{Re-fit a model object using the complete model data}
\usage{
fit(x, ...)

\method{fit}{model}(
  x,
  eval = TRUE,
  use_original_args = FALSE,
  force = FALSE,
  env = parent.frame(),
  ...
)

\method{fit}{multimodel}(
  x,
  eval = TRUE,
  use_original_args = FALSE,
  force = FALSE,
  which,
  env = parent.frame(),
  ...
)

\method{fit}{cv}(
  x,
  eval = TRUE,
  use_original_args = FALSE,
  force = FALSE,
  which,
  env = parent.frame(),
  ...
)

add_fit(x, ...)

has_fit(x)

\method{fit}{model_fm_glmnet}(x, iter, eval = TRUE, force = FALSE, ...)

\method{fit}{model_fm_xgb}(x, iter, eval = TRUE, force = FALSE, ...)
}
\arguments{
\item{x}{A \dQuote{model} object}

\item{\dots}{Passed to the model fitting function.}

\item{eval}{Logical: If \code{FALSE}, the call to the model fitting function is returned, but not executed.}

\item{use_original_args}{Logical: If \code{FALSE}, the model generating call is evaluated internally,
using the data (and potential additional objects) saved in \code{x};
if \code{TRUE}, evaluation takes place in the calling environment of \code{fit()}, using the original input data.}

\item{force}{Logical: If \code{FALSE} and a fitted model is present as the \code{fit} component of the model \code{x},
then this fit is returned. If \code{force=TRUE}, the model will be re-fitted in any case.}

\item{env}{An environment. Used for internal purposes.}

\item{which}{Selection of one model: An integer value
or a logical vector of length \code{n_model(x)} having exactly one \code{TRUE},
or a character value (selection by name, a model's \code{label}).
If \code{n_model(x)==1}, the only model is selected by default.}

\item{iter}{iteration}
}
\value{
\code{fit()} returns a fitted model. \code{add_fit()} returns an object of class \dQuote{\link{model}}.
\code{has_fit()} returns a logical vector of length \code{n_model(x)}.
}
\description{
Fits the fitted model (such as \code{lm}) expressed in a \dQuote{\link{model}} object using the complete model data.
In a way, \code{fit()} is the inverse operation of \code{model()}.

\code{add_fit()} adds the model fit to a \dQuote{model} object, as its component \code{fit} (if not already present).
The methods for classes \dQuote{multimodel}  and \dQuote{cv} similarly add the fitted models
to all included models.

\code{has_fit()} is a generic function that discerns whether a (multi-)model contains the
corresponding fitted model(s).
}
\details{
\code{fit()} is generic and has specific methods for classes \dQuote{model_fm_glmnet} and \dQuote{model_fm_xgb}.
See \code{\link{fm_glmnet}}, \code{\link{fm_xgb}} and the examples below.

For \emph{iteratively fitted models} (\link{ifm}s, currently classes  \dQuote{fm_xgb} and \dQuote{fm_glmnet}),
\code{fit()} executes \code{\link{set_pref_iter}()} internally.
If there is information on the preferred iteration (from a cross-validation) attached to \code{x},
the call to the model generating function is thereby adjusted.
To suppress this adjustment, run \code{fit()} with \code{iter=NULL}.

Another peculiarity of \code{fit(x)} when \code{x} is an IFM and has information on preferred iterations
comes into play when, in addition, \code{x} has a model fit attached to it (i.e. \code{has_fit(x)==TRUE}).
In this case, the fitted model is partially adapted according to the preferred iteration.
Specifically, the \code{pref_iter} is set in the fitted model and in the call
(and more parameters related to stopping or choice of iteration for predictions are modified).
The model fit attached to the output is improper in the sense that
it differs from what would result when you execute its call (but predictions are the same).
This default behavior can be suppressed by setting \code{force=TRUE}, which consequently increases execution time
by the time required to fit the model.
}
\section{Methods}{

\itemize{
\item{\code{fit.model()} converts the \dQuote{model} object \code{x} to a fitted model of class \code{x$class}.}
\item{\code{fit.multimodel()} and \code{fit.cv()} extract a single model from \code{x} according to argument \code{which}
(see \code{\link{extract_model}()}) and applies \code{fit.model()} to the result.}
\item{\code{fit.model_fm_glmnet()} and \code{fit.model_fm_xgb()} are specific methods for these two model classes.
A special feature of these methods goes into action if \code{x} contains results on preferred iteration resulting from a cross-validation.
In that case the preferred iteration is selected from the cross-validation results
(see \code{\link{set_pref_iter}()}).}
}
}

\examples{
# Applying model() then fit() to a model returns the original model:
mod <- model(lm(Sepal.Width ~ ., iris), label = "lm")
mod
fit(mod)

# Obtain the model call without executing it:
fit(mod, eval = FALSE)
# Note the generic 'data=data' in the result
# In order to obtain the original call, do:
fit(mod, eval = FALSE, use_original_args = TRUE)

}
\seealso{
\code{\link{model}}; \code{\link{set_pref_iter}}; \code{\link{fm_xgb}} and \code{\link{fm_glmnet}}.
}
