% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model.R
\name{model}
\alias{model}
\alias{model.default}
\alias{model.call}
\alias{model.character}
\alias{model.model}
\alias{print.model}
\title{Create a model object}
\usage{
model(x, ...)

\method{model}{default}(
  x,
  label = "model",
  class = attr(x, "class"),
  add_fit = TRUE,
  response_type = NULL,
  predict_function = predict,
  env = parent.frame(),
  ...
)

\method{model}{call}(x, label = "model", class, add_fit = FALSE, env = parent.frame(), ...)

\method{model}{character}(x, ..., label = "model", class, add_fit = FALSE, env = parent.frame())

\method{model}{model}(x, ...)

\method{print}{model}(
  x,
  what = c("label", "class", "formula", "data", "response_type", "weights", "call",
    "fit"),
  abbreviate = TRUE,
  width = getOption("width"),
  indent = "",
  ...
)
}
\arguments{
\item{x}{A fitted model meeting the formal requirements described in the \dQuote{Details} section.
Alternatively, an unevaluated call to a model fitting function; in that case,
the model class must be provided as argument \code{class} (see examples).}

\item{\dots}{Arguments passed to methods. Not used in the default method.}

\item{label}{Character string: A label to be attributed to the model.}

\item{class}{Class of the model object. Not required if \code{x} is a fitted model.}

\item{add_fit}{Logical: Save the fitted object as a component of the result?}

\item{response_type}{Character string, \code{"continuous"} or \code{"binary"}.
Default: \code{"binary"} if all response values (converted to numeric) are 0 or 1, else \code{"continuous"}.}

\item{predict_function}{Predict function, often \code{\link{predict}} - see \dQuote{Details}.}

\item{env}{An environment. Used for internal purposes.}

\item{what}{What to print: Either a character vector being a subset of \{"label",
"formula", "data", "call", "response_type", "response", "fit",
"predict_function", "saved_objects", "class", "weights"\}
or \code{TRUE}, meaning all of these elements.}

\item{abbreviate}{Logical. If \code{TRUE} (the default), long formulas and calls are printed in abbreviated mode,
such that they usually fit on 4 or fewer output lines; otherwise they are printed entirely, no matter how long they are.}

\item{width}{Integer: Width of printed output.}

\item{indent}{Used internally only.}
}
\value{
\code{model()} returns a list with class attribute \code{c(paste0("model_", class), "model")} having the following elements:
\itemize{
\item{\emph{label}, a character string used as identifier of the model;}
\item{\emph{formula}, a \code{\link{formula}} defining the model's structure;}
\item{\emph{data}, a \code{data.frame};}
\item{\emph{call}, the call fitting the model;}
\item{\emph{response_type}, character string, \code{"continuous"} or \code{"binary"};}
\item{\emph{response}, character string containing the variable name or expression defining the response;}
\item{\emph{fit} (optional), the fitted object of class \code{class};}
\item{\emph{predict_function}, a real valued function with two arguments:
A model and a data of the same structure as \emph{data};}
\item{\emph{saved_objects}, a list of objects appearing in the \emph{call} and not being part of the \emph{data};}
\item{\emph{class}, the class of the fitted model;}
\item{\emph{weights}, an optional vector of fitting weights.}
}
}
\description{
\code{model()} takes a fitted statistical model \code{x}, e.g. a \code{\link{lm}},
and returns an output of class \dQuote{model},
an R object containing the model's structure, the data and optionally the fitting weights.
The \dQuote{model} object does not necessarily contain the model fit, but has all information needed to refit
the model, possibly after making changes to the generating call.
\code{model()} works for fitted models created by a model fitting function having a \code{formula} and a \code{data} argument.

\code{model()} is applicable to many popular model classes such as \code{\link{lm}},
\code{\link[robustbase]{lmrob}}, \code{\link[rpart]{rpart}}, \code{\link[lme4]{lmer}}
and many more.
}
\details{
Model classes suited for \code{model()} must meet the following requirements:
\itemize{
\item{The model fitting function must have formal arguments \code{formula} and \code{data},
accepting a \code{\link{formula}} and a \code{\link{data.frame}}, respectively.}
\item{In case of a binary response, the response must be numeric and have values 0 or 1.}
\item{\code{\link{getCall}(x)} with \code{x} a model of the class in question must return the call generating \code{x}.}
\item{There should usually be a \code{\link{predict}} method for the class of \code{x}
returning a vector of length \code{nrow(data)}.
Alternatively, a real valued function with two arguments, a model and a \code{data.frame},
can be specified as the \code{predict_function}.}
\item{If weighted fitting is required, the model fitting function must have
an argument \code{weights}. In that case, there should be an appropriate \code{\link[stats]{weights}}
method for the class \code{class} returning either \code{NULL} or a vector of non-negative values of length \code{nrow(data)}.
However, a model class not supporting weighted fitting will work as long as you do not
specify \code{weights} in \code{model()}.}
}

The \emph{model generating call} is saved in the output object in a partially generic mode.
Specifically, the arguments \code{data} and \code{weights} (if present) are given generic values \code{data=data} and
\code{weights=weights}, respectively. This is convenient for cross-validation with \code{\link{cv}()},
where the model generating call is repeatedly adapted and executed internally, using data and weights stored in the
\dQuote{model} object. See also the argument \code{use_original_args} in \code{\link{fit}()}, which is related to
this reformulation of the model generating call.
}
\section{Note}{

If the current settings of the options \code{na.action} and \code{contrasts} (or other options) potentially change the behavior
of the model fitting function, then changing these options during an analysis involving that type of model must be avoided.
}

\section{Methods}{

\itemize{
\item{\code{model.call()} and \code{model.character()} allow creating a \dQuote{model} object  without having to fit the
corresponding model. See examples. Specifying the  \code{class} is mandatory here,
as it can not be queried from the input \code{x}.}
\item{There is a method \code{model.model()} that returns its input \code{x} unchanged.}
}
}

\examples{
# lm
fitted <- lm(Sepal.Width ~ ., iris)
mod1 <- model(fitted, label = "LinearModel")
mod1

# weighted lm
model(lm(Sepal.Width ~ ., iris, weights = runif(nrow(iris))), 
      label = "weightedLm")

# print.model
print(mod1, what = TRUE)
print(mod1, what = c("label", "call", "class"))
print(mod1, what = NULL)

# model() applied to an unevaluated call:
lm_call <- quote(lm(Sepal.Width~., iris))
model(lm_call, class = "lm")
# Same using the method model.character():
model("lm", Sepal.Width~., iris, class = "lm")

}
\seealso{
\code{\link{multimodel}}, \code{\link{model-methods}}, \code{\link{update.model}}, \code{\link{fit}}
}
