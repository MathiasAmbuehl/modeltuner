% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_methods.R
\name{plot.model}
\alias{plot.model}
\alias{plot.multimodel}
\alias{plot.cv}
\title{Plot methods for classes \dQuote{model}, \dQuote{multimodel} and \dQuote{cv}}
\usage{
\method{plot}{model}(x, plot = TRUE, n_max = 5000, ...)

\method{plot}{multimodel}(x, plot = TRUE, n_max = 5000, ...)

\method{plot}{cv}(x, plot = TRUE, n_max = 5000, ...)
}
\arguments{
\item{x}{Object of appropriate class.}

\item{plot}{Logical: If \code{TRUE}, a ggplot is returned, if \code{FALSE} a \code{data.frame}.
\code{plot()} first prepares a \code{data.frame} and then draws some ggplot using this data,
with limited options for customization.
If you want to design your own plot, you can set \code{plot=FALSE}, and use the \code{data.frame} returned by \code{plot()}
to create your plot.}

\item{n_max}{Integer: Maximal number of points to draw in a scatter plot.
If size of data is larger than \code{n_max}, a random sample will be displayed.}

\item{\dots}{Passed to \code{\link{geom_point}()} or \code{\link{geom_violin}()} (in case of binary response), respectively.}
}
\value{
These \code{plot()} methods return either a \link[ggplot2]{ggplot} or, if \code{plot=FALSE}, a \code{data.frame}.
}
\description{
\code{plot.model()} and \code{plot.multimodel()} \code{\link{fit}} the model(s) in \code{x} and draw scatter plot(s) of
actual response values versus fitted values in case of a continuous response.
With binary response, a violin plot of the fitted values versus the response variable is produced
(using \code{\link{geom_violin}()}).

\code{plot.cv} creates a similar plot, using the predictions resulting from cross-validation
(generated with \code{\link{cv_predict}}) as fitted values.
}
\details{
The lengths of the errorbars corresponds to +/-1 standard error.
}
\examples{
# Simulate data 
set.seed(1)
n <- 50
x <- rnorm(n)
y <- 3*x + rnorm(n)
mymodel <- model(lm(y~x))
# Plot in-sample and out-of-sample predictions:
if (require(ggplot2) && require(gridExtra)){
  plot(gridExtra::arrangeGrob(
       plot(mymodel) + ggtitle("response vs. in-sample predictions"),
       plot(cv(mymodel)) + ggtitle("response vs. out-of-sample predictions"), 
       nrow = 1))
}   

# Binary response: binomial response
# Simulate data 
n <- 100
p <- 10
x <- matrix(rnorm(p*n), nrow = n)
y <- (0.1 * rowSums(x) + rnorm(n)) > 0
mymodel <- model(glm(y~x, family = binomial))
# Plot in-sample and out-of-sample predictions:
if (require(ggplot2) && require(gridExtra)){
  plot(gridExtra::arrangeGrob(
       plot(mymodel) + ggtitle("response vs. in-sample predictions"),
       plot(cv(mymodel)) + ggtitle("response vs. out-of-sample predictions"), 
       nrow = 1))
}

}
\seealso{
\code{\link{model}}, \code{\link{multimodel}}, \code{\link{cv}}
}
