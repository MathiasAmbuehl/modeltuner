% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multimodel.R
\name{multimodel}
\alias{multimodel}
\alias{multimodel.model}
\alias{multimodel.default}
\alias{multimodel.multimodel}
\alias{print.multimodel}
\alias{c.model}
\alias{c.multimodel}
\title{Create a multimodel object}
\usage{
multimodel(x, ...)

\method{multimodel}{model}(
  x,
  ...,
  prefix = label(x),
  expand = TRUE,
  max_n_model = getOption("expand_max_model"),
  param = TRUE,
  simplify = TRUE
)

\method{multimodel}{default}(
  x,
  ...,
  prefix = "model",
  expand = TRUE,
  param = TRUE,
  simplify = TRUE
)

\method{multimodel}{multimodel}(x, ...)

\method{print}{multimodel}(
  x,
  what = c("class", "formula", "data", "weights", "call", "cv_info"),
  abbreviate = TRUE,
  n = getOption("print_max_model"),
  param = TRUE,
  width = getOption("width"),
  ...
)

\method{c}{model}(..., param = TRUE, simplify = TRUE)

\method{c}{multimodel}(..., param = TRUE, simplify = TRUE)
}
\arguments{
\item{x}{An object of class \dQuote{model} or a fitted model.}

\item{\dots}{In \code{multimodel()}: \emph{named} parameters to be expanded;
in \code{c.}(\code{multi})\code{model}: one or several arguments of class \dQuote{model} or \dQuote{multimodel}.}

\item{prefix}{Prefix to use for the model \code{\link{label}}.}

\item{expand}{Logical: Expand the \dQuote{...} arguments (default) or join them element-wise?
If \code{expand=TRUE}, the vectors in \dQuote{...} will be expanded, the number of models will equal the product
of the lengths of the \dQuote{...} arguments;
otherwise, all \dQuote{...} arguments must have equal lengths, and the number of models will be equal to their common length.}

\item{max_n_model}{Maximal number of models that will be included.
If the number of specified models is greater than \code{max_n_model}, a subset will be selected at random.}

\item{param}{Logical: Keep or print parameter table?}

\item{simplify}{Logical: Simplify a \code{multimodel} comprising only one model to a \code{\link{model}}?}

\item{what}{Which elements of the multimodel should be printed? See \code{\link{print.model}}.}

\item{abbreviate}{Logical. If \code{TRUE} (the default), long formulas and calls are printed in abbreviated mode,
such that they usually fit on 4 or fewer output lines; otherwise they are printed entirely, no matter how long they are.}

\item{n}{Integer: Model details are printed for first \code{n} models.}

\item{width}{Integer: Width of printed output.}
}
\value{
\code{multimodel()} and \code{c.}(\code{multi})\code{model()} both return an object of class \dQuote{multimodel}, this is
a \code{list} with the following elements:
\itemize{
\item{\emph{models}: A list of the \code{\link{model}} objects.}
\item{\emph{param}: The table of the parameter values resulting from \code{multimodel()}.
Only included if there are any varying parameters and if \code{param = TRUE}}
}
}
\description{
A multimodel combines several \code{\link{model}}s with identical response in one object.
There are two ways to create a multimodel:
\itemize{
\item{\code{multimodel(x, ...)} takes an object of class \dQuote{model} or a fitted model as its input \code{x}
and generates a number of variations of this model, with one or several parameters varying according to the specification in \dQuote{...}.}
\item{\code{c.model(...)} and \code{c.multimodel(...)} take a number of \code{model}s or \code{multimodel}s
as their \dQuote{...} arguments and combine them in an object of class \dQuote{multimodel}.
}}
}
\details{
\code{multimodel()} is a  (S3-)generic function.
The core method is \code{multimodel.model()}, other methods are essentially wrappers to the core method and are described in the section \dQuote{Methods} below.
The vectors in \dQuote{...} are expanded or joined, according to the argument \code{expand}.
Extraction of values for the single calls is done with \dQuote{\code{[[}} rather than \dQuote{\code{[}}.

\code{multimodel()} executes \code{\link{update.model}()} repeatedly, such that the helper functions \code{\link{absent}()},
\code{\link{unchanged}()} and \code{\link{null}()} can be used in a call to \code{multimodel()} exactly as within \code{update.model()}.

If \code{formula} is one of the arguments in the \dQuote{...} and some formula has a dot, it will be used to \emph{update} the original model formula.
Enclose a formula in \code{I()} in order to \emph{replace} the original formula instead.
See the example below and \code{\link{update.model}}.

The output of \code{multimodel(...)} by default includes a \emph{parameter table} as its element \code{param}, containing the values
of the parameters specified in the \dQuote{...}.
This is a \code{data.frame} having an additional class \dQuote{\link{param_table}}.

\code{c.}(\code{multi})\code{model}: A call to \code{c(...)} can include both \dQuote{model} and \dQuote{multimodel} objects
(but no fitted models) in its \dQuote{...}.
Using \code{\link{models}()} instead of these \code{c}-methods is more flexible in that it also accepts \emph{fitted} models.

\dQuote{model}s specified as named arguments in the call will have their argument name taken as their \code{\link{label}}.
Argument names for multimodels are ignored -- the \code{label}s already present in the multimodel will be used instead.
Duplicate labels in the output will be adjusted using \code{\link{make.unique}()}.
}
\section{Methods}{

\itemize{
\item{\code{multimodel.model()} is described in the \dQuote{Details} section.}
\item{The default method expects a fitted model as its \code{x} and executes \code{x \%>\% model \%>\% multimodel(...)}.}
\item{\code{multimodel.multimodel()} returns its input \code{x} unchanged.}
}
}

\examples{
m1 <- model(lm(Sepal.Length ~ 1 , iris), label = "intercept")
m2 <- model(lm(Sepal.Length ~ . , iris), label = "linear")
m3 <- model(lm(Sepal.Length ~ .^2 , iris), label = "order2")  # without Species on rhs

# Combine models with c(...)
mm1 <- c(m1, m2, m3) 
mm1

# Specify elements to print:
print(mm1, what = c("class", "data"))
print(mm1, what = TRUE)

# Expand a model with multimodel(): random forests with different max.depth:
if (require(ranger)){
  mod_ranger <- model(ranger(Sepal.Length ~ ., iris), label = "ranger")
  multimodel(mod_ranger, max.depth = 1:10)
}

#' # Expand a model with multimodel(...)
# Joining models with three formulas may not give the expected result:
mm2 <- multimodel(m1, formula = list(Sepal.Length ~ 1, Sepal.Length ~ ., Sepal.Length ~ .^2))
mm2 
# The reason is that the formulas in the call above are used to *update* the existing one. 
# To *replace* the formula, use `I()` as in the call below:
mm3 <- multimodel(m1, formula = list(Sepal.Length ~ 1, I(Sepal.Length ~ .), I(Sepal.Length ~ .^2)))
mm3
# Also note the difference in the printed outputs of mm1 and mm2:
# The parameter table only contains parameters that were passed as '...' in multimodel().

# Three ways to attribute labels to models:
# 1) Use named arguments in c.model():
c(constant = m1, linear = m2, order2 = m3) 
# 2) replacement function label<-
mm1_lbls <- mm1
label(mm1_lbls) <- c("m1", "m2", "m3")
mm1_lbls
# 3) set_labels()
set_label(mm1, c("m1", "m2", "m3"))

# Combine mm1 and mm3:
print(c(mm1, mm3), what = "formula", n = 6)

# Unweighted and weighted model:
w <- runif(150)
mm3 <- multimodel(m1, weights = list(absent(), w))
label(mm3) <- c("unweighted", "weighted")
mm3

}
\seealso{
\code{\link{label}}, \code{\link{extract_model}}, \code{\link{subset}}, \code{\link{sort_models}},
\code{\link{update.model}}, \code{\link{expand_formula}}.

\code{\link{models}()} is a more general version of \code{c.}(\code{multi})\code{model} also accepting fitted models.
}
